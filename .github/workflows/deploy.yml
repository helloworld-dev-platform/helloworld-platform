name: backend_deploy

# main 브랜치에 push 이벤트 발생 시 실행
on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: [ self-hosted ]
    env:
      REGISTRY: docker.io
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      IMAGE_NAMES: "backend-server,websocket-server"
      NGROK_TOKEN: ${{ secrets.NGROK_TOKEN }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      # --------------------------------------------------------
      # 1) 롤백을 위한 이전 버전(latest) 백업
      - name: Tag previous versions for rollback
        shell: powershell
        run: |
          foreach ($imageName in "${{ env.IMAGE_NAMES }}".Split(',')) {
               docker pull ${{ env.REGISTRY }}/${{ env.DOCKER_USERNAME }}/$imageName:latest
               if ($LASTEXITCODE -ne 0) {
               Write-Warning "Failed to pull 'latest' for $imageName. It might be the first deployment."
             }
          
               docker tag ${{ env.REGISTRY }}/${{ env.DOCKER_USERNAME }}/$imageName:latest ${{ env.REGISTRY }}/${{ env.DOCKER_USERNAME }}/$imageName:previous
               if ($LASTEXITCODE -ne 0) {
               Write-Warning "Failed to tag 'previous' for $imageName."
             }
          
               docker push ${{ env.REGISTRY }}/${{ env.DOCKER_USERNAME }}/$imageName:previous
               if ($LASTEXITCODE -ne 0) {
               Write-Warning "Failed to push 'previous' for $imageName."
             }
          }

      # --------------------------------------------------------
      # 2) 새 버전 빌드 & 푸시 & 배포
      - name: Build, Push and Deploy new versions
        id: deploy-step
        continue-on-error: true
        shell: powershell
        run: |
          docker compose build
          
          # 빌드된 모든 이미지에 대해 태그 지정 및 푸시 반복
          foreach ($imageName in "${{ env.IMAGE_NAMES }}".Split(',')) {
            Write-Host "Tagging and pushing image: $imageName"
            $imageFullName = "${{ env.DOCKER_USERNAME }}/$imageName"
            $registryFullName = "${{ env.REGISTRY }}/$imageFullName"
          
            docker tag $imageFullName:latest $registryFullName:latest
            docker tag $imageFullName:latest $registryFullName:${{ github.sha }}
          
            docker push $registryFullName:latest
            docker push $registryFullName:${{ github.sha }}
          }
          
          docker compose up -d

      # --------------------------------------------------------
      # 3) 롤백 (빌드/배포 실패 시 이전 이미지로 복구)
      - name: Rollback to last successful version
        if: ${{ steps.deploy-step.outcome != 'success' }}
        shell: powershell
        run: |
          Write-Host "Deployment failed - rolling back to last known good state"
          $env:IMAGE_TAG="previous"
          docker compose up -d
          exit 1

      # --------------------------------------------------------
      # 4) ngrok 터널링 (배포 성공 시에만 실행됩니다)
      - name: Setup ngrok with cache
        id: setup-ngrok
        uses: actions/cache@v4
        with:
          path: ngrok.exe #ngrok설치파일 캐싱
          key: ${{ runner.os }}-ngrok-v3 #캐시 식별 고유키

      - name: Download and start ngrok
        id: ngrok
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          
          # ngrok 다운로드
          if ($env:CACHE_HIT -ne 'true') {
            Write-Host "ngrok not found in cache. Downloading..."
            Invoke-WebRequest https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip -OutFile ngrok.zip
            Expand-Archive ngrok.zip -DestinationPath .
          } else {
            Write-Host "ngrok restored from cache."
          }
          
          #ngrok.yml 파일 환경변수 설정
          $ngrokTemplatePath = "${{ github.workspace }}/ngrok.yml"
          $ngrokConfigPath = "ngrok-config.yml" 
          
          $content = Get-Content $ngrokTemplatePath
          $content = $content -replace '\${NGROK_TOKEN}', "$env:NGROK_TOKEN"
          Set-Content -Path $ngrokConfigPath -Value $content
          
          # ngrok.yml을 config로 터널 시작
          Start-Process -FilePath .\ngrok.exe -ArgumentList "start --all --config $ngrokConfigPath --log=stdout" -RedirectStandardOutput ngrok.log -NoNewWindow
          
          # ngrok API 준비될때까지 5회 재시도
          Write-Host "Waiting for ngrok API to be ready..."
          $maxRetries = 5
          $retryDelay = 3
          for ($i=0; $i -lt $maxRetries; $i++) {
              try {
                  Start-Sleep -Seconds $retryDelay
                  $data = Invoke-RestMethod http://127.0.0.1:4040/api/tunnels -ErrorAction Stop
                  if ($data.tunnels.Count -gt 0) {
                      Write-Host "ngrok API is ready."
                      break
                  }
              } catch {
                  Write-Host "ngrok API not ready, retrying... ($($i+1)/$maxRetries)"
              }
              if ($i -eq ($maxRetries - 1)) {
                  Write-Error "Failed to connect to ngrok API after $maxRetries retries."
                  exit 1
              }
          }
          
          # 퍼블릭URL 조회
          $api = ($data.tunnels | Where-Object { $_.name -eq "api" }).public_url
          $ws  = ($data.tunnels | Where-Object { $_.name -eq "ws" }).public_url
          
          # GitHub Actions Outputs 설정
          "api_url=$api" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "ws_url=$ws"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Show public URLs
        shell: powershell
        run: |
          Write-Host "REST API    ${{ steps.ngrok.outputs.api_url }}"
          Write-Host "WebSocket   ${{ steps.ngrok.outputs.ws_url }}"

      # --------------------------------------------------------
      # 5) 배포 성공 시 Discord 알림
      - name: Discord Notification (Success)
        if: ${{ success() }}
        shell: powershell
        run: |
          $webhook = $env:DISCORD_WEBHOOK_URL
          $jsonBody = @{
            "content" = ""
            "embeds" = @(
              @{
                "title" = "✅ 배포 성공!"
                "color" = 65280 # Green
                "fields" = @(
                  @{
                    "name" = "REST API"
                    "value" = "${{ steps.ngrok.outputs.api_url }}"
                    "inline" = $false
                  },
                  @{
                    "name" = "WebSocket"
                    "value" = "${{ steps.ngrok.outputs.ws_url }}"
                    "inline" = $false
                  }
                )
              }
            )
          } | ConvertTo-Json -Depth 5 -Compress
          
          # JSON 문자열을 UTF-8 형식으로 임시 파일에 저장
          $jsonBody | Out-File -FilePath payload.json -Encoding utf8
          
          # curl을 사용해 임시 파일을 본문으로 전송 (-d @파일이름)
          curl.exe -X POST -H "Content-Type: application/json" -d "@payload.json" -v $webhook
      # --------------------------------------------------------
      # 6) 배포 실패 시 Discord 알림 (롤백 직후 실행)
      - name: Discord Notification (Failure)
        if: ${{ failure() }}
        shell: powershell
        run: |
          $webhook = $env:DISCORD_WEBHOOK_URL
          $jsonBody = @{
            "content" = ""
            "embeds" = @(
              @{
                "title" = "❌ 배포 실패!"
                "description" = "배포에 실패하여 이전 버전으로 롤백했습니다."
                "color" = 16711680 # Red
              }
            )
          } | ConvertTo-Json -Depth 5 -Compress
          
          # JSON 문자열을 UTF-8 형식으로 임시 파일에 저장
          $jsonBody | Out-File -FilePath payload.json -Encoding utf8

          # curl을 사용해 임시 파일을 본문으로 전송 (-d @파일이름)
          curl.exe -X POST -H "Content-Type: application/json" -d "@payload.json" -v $webhook