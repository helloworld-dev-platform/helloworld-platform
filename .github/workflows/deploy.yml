name: backend_deploy

# main 브랜치에 push 이벤트 발생 시 실행
on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: [ self-hosted ]
    env:
      REGISTRY: docker.io
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      IMAGE_NAMES: "backend-server,websocket-server"
      NGROK_TOKEN: ${{ secrets.NGROK_TOKEN }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      # 1) 롤백을 위한 이전 버전(latest) 백업
      - name: Tag previous versions for rollback
        shell: powershell
        run: |
          foreach ($imageName in "${{ env.IMAGE_NAMES }}".Split(',')) {
            Write-Host "Attempting to back up latest version of $imageName..."
            docker pull ${{ env.REGISTRY }}/${{ env.DOCKER_USERNAME }}/$imageName:latest
          
            # docker pull이 성공했을 때만, tag와 push를 실행
            if ($LASTEXITCODE -eq 0) {
              Write-Host "Pull successful. Tagging and pushing 'previous' version of $imageName."
          
              docker tag ${{ env.REGISTRY }}/${{ env.DOCKER_USERNAME }}/$imageName:latest ${{ env.REGISTRY }}/${{ env.DOCKER_USERNAME }}/$imageName:previous
              if ($LASTEXITCODE -ne 0) {
                # tag 실패, Error로 표시
                Write-Error "Failed to tag 'previous' for $imageName."
              }
          
              docker push ${{ env.REGISTRY }}/${{ env.DOCKER_USERNAME }}/$imageName:previous
              if ($LASTEXITCODE -ne 0) {
                # push 실패, Error로 표시
                Write-Error "Failed to push 'previous' for $imageName."
              }
            } else {
              # pull 실패 시 (첫 배포 등)
              Write-Warning "Could not pull 'latest' for $imageName. This might be the first deployment. Skipping backup."
            }
          }

      # --------------------------------------------------------
      # 2) 새 버전 빌드 & 푸시 & 배포
      - name: Build, Push and Deploy new versions
        id: deploy-step
        continue-on-error: true
        shell: powershell
        run: |
          docker compose build
          
          # 빌드된 모든 이미지에 대해 태그 지정 및 푸시 반복
          foreach ($imageName in "${{ env.IMAGE_NAMES }}".Split(',')) {
            Write-Host "Tagging and pushing image: $imageName"
            $imageFullName = "${{ env.DOCKER_USERNAME }}/$imageName"
            $registryFullName = "${{ env.REGISTRY }}/$imageFullName"
          
            docker tag $imageFullName:latest $registryFullName:latest
            docker tag $imageFullName:latest $registryFullName:${{ github.sha }}
          
            docker push $registryFullName:latest
            docker push $registryFullName:${{ github.sha }}
          }
          
          docker compose up -d

      # --------------------------------------------------------
      # 3) 롤백 (빌드/배포 실패 시 이전 이미지로 복구)
      - name: Rollback to last successful version
        if: ${{ steps.deploy-step.outcome != 'success' }}
        shell: powershell
        run: |
          Write-Host "Deployment failed - rolling back to last known good state"
          $env:IMAGE_TAG="previous"
          docker compose up -d
          exit 1

      # --------------------------------------------------------
      # 4) ngrok 터널링 (배포 성공 시에만 실행됩니다)
      - name: Setup ngrok with cache
        id: setup-ngrok
        uses: actions/cache@v4
        with:
          path: ngrok.exe #ngrok설치파일 캐싱
          key: ${{ runner.os }}-ngrok-v3 #캐시 식별 고유키

      - name: Download and start ngrok
        id: ngrok
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          
          # ngrok 다운로드
          if ($env:CACHE_HIT -ne 'true') {
            Write-Host "ngrok not found in cache. Downloading..."
            Invoke-WebRequest https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip -OutFile ngrok.zip
            Expand-Archive ngrok.zip -DestinationPath .
          } else {
            Write-Host "ngrok restored from cache."
          }
          
          #ngrok.yml 파일 환경변수 설정
          $ngrokTemplatePath = "${{ github.workspace }}/ngrok.yml"
          $ngrokConfigPath = "ngrok-config.yml" 
          
          $content = Get-Content $ngrokTemplatePath
          $content = $content -replace '\${NGROK_TOKEN}', "$env:NGROK_TOKEN"
          Set-Content -Path $ngrokConfigPath -Value $content
          
          # ngrok.yml을 config로 터널 시작
          Start-Process -FilePath .\ngrok.exe -ArgumentList "start --all --config $ngrokConfigPath --log=stdout" -RedirectStandardOutput ngrok.log -NoNewWindow
          
          # ngrok API 준비될때까지 5회 재시도
          Write-Host "Waiting for ngrok API to be ready..."
          $maxRetries = 5
          $retryDelay = 3
          for ($i=0; $i -lt $maxRetries; $i++) {
              try {
                  Start-Sleep -Seconds $retryDelay
                  $data = Invoke-RestMethod http://127.0.0.1:4040/api/tunnels -ErrorAction Stop
                  if ($data.tunnels.Count -gt 0) {
                      Write-Host "ngrok API is ready."
                      break
                  }
              } catch {
                  Write-Host "ngrok API not ready, retrying... ($($i+1)/$maxRetries)"
              }
              if ($i -eq ($maxRetries - 1)) {
                  Write-Error "Failed to connect to ngrok API after $maxRetries retries."
                  exit 1
              }
          }
          
          # 퍼블릭URL 조회
          $api = ($data.tunnels | Where-Object { $_.name -eq "api" }).public_url
          $ws  = ($data.tunnels | Where-Object { $_.name -eq "ws" }).public_url
          
          # GitHub Actions Outputs 설정
          "api_url=$api" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "ws_url=$ws"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Show public URLs
        shell: powershell
        run: |
          Write-Host "REST API    ${{ steps.ngrok.outputs.api_url }}"
          Write-Host "WebSocket   ${{ steps.ngrok.outputs.ws_url }}"

      # --------------------------------------------------------
      # 5) 배포 성공 시 Discord 알림
      - name: Discord Notification (Success)
        if: ${{ success() }}
        run: |
          curl -H "Content-Type: application/json" -X POST "${{ env.DISCORD_WEBHOOK_URL }}" \
            -d "{\"content\":\" Deploy Success!\n• REST API: ${{ steps.ngrok.outputs.api_url }}\n• WebSocket: ${{ steps.ngrok.outputs.ws_url }}\"}"
      # --------------------------------------------------------
      # 6) 배포 실패 시 Discord 알림 (롤백 직후 실행)
      - name: Discord Notification (Failure)
        if: ${{ failure() }}
        run: |
          curl -H "Content-Type: application/json" -X POST "${{ env.DISCORD_WEBHOOK_URL }}" \
            -d "{\"content\":\" Deploy failure..rollback complete.\"}"