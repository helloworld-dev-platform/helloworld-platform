name: backend_deploy

# main 브랜치에 push 이벤트 발생 시 실행
on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: [ self-hosted ]
    env:
      NGROK_TOKEN: ${{ secrets.NGROK_TOKEN }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # --------------------------------------------------------
      # 1) 빌드 & 배포: 오류 나도 바로 실패 처리하지 않고 다음 스텝에서 판단
      - name: Build & start containers
        id: deploy-step
        continue-on-error: true
        run: |
          docker compose up -d --build

      # --------------------------------------------------------
      # 2) 롤백 (빌드/배포 실패 시 이전 이미지로 복구)
      - name: Rollback to last successful version
        if: ${{ steps.deploy-step.outcome != 'success' }}
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          Write-Host "Deployment failed - rolling back to last known good state"
          docker compose down
          docker compose up -d --no-build
          exit 1

      # --------------------------------------------------------
      # 3) ngrok 터널링 (배포 성공 시에만 실행됩니다)
      - name: Setup ngrok with cache
        id: setup-ngrok
        uses: actions/cache@v4
        with:
          path: ngrok.exe #ngrok설치파일 캐싱
          key: ${{ runner.os }}-ngrok-v3 #캐시 식별 고유키

      - name: Download and start ngrok
        id: ngrok
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          
          # ngrok 다운로드
          if ($env:CACHE_HIT -ne 'true') {
            Write-Host "ngrok not found in cache. Downloading..."
            Invoke-WebRequest https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip -OutFile ngrok.zip
            Expand-Archive ngrok.zip -DestinationPath .
          } else {
            Write-Host "ngrok restored from cache."
          }
          
          #ngrok.yml 파일 환경변수 설정
          $ngrokConfigPath = "${{ github.workspace }}/.github/workflows/ngrok.yml"
          $content = Get-Content $ngrokConfigPath
          $content = $content -replace '\${NGROK_TOKEN}', "$env:NGROK_TOKEN"
          Set-Content -Path $ngrokConfigPath -Value $content
          
          # ngrok.yml을 config로 터널 시작
          Start-Process -FilePath .\ngrok.exe -ArgumentList "start --all --config ngrok.yml --log=stdout" -RedirectStandardOutput ngrok.log -NoNewWindow
          
          # ngrok API 준비될때까지 5회 재시도
          Write-Host "Waiting for ngrok API to be ready..."
          $maxRetries = 5
          $retryDelay = 3
          for ($i=0; $i -lt $maxRetries; $i++) {
              try {
                  Start-Sleep -Seconds $retryDelay
                  $data = Invoke-RestMethod http://127.0.0.1:4040/api/tunnels -ErrorAction Stop
                  if ($data.tunnels.Count -gt 0) {
                      Write-Host "ngrok API is ready."
                      break
                  }
              } catch {
                  Write-Host "ngrok API not ready, retrying... ($($i+1)/$maxRetries)"
              }
              if ($i -eq ($maxRetries - 1)) {
                  Write-Error "Failed to connect to ngrok API after $maxRetries retries."
                  exit 1
              }
          }
          
          # 퍼블릭URL 조회
          $api = ($data.tunnels | Where-Object { $_.name -eq "api" }).public_url
          $ws  = ($data.tunnels | Where-Object { $_.name -eq "ws" }).public_url
          
          # GitHub Actions Outputs 설정
          "api_url=$api" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "ws_url=$ws"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Show public URLs
        shell: powershell
        run: |
          Write-Host "REST API    ${{ steps.ngrok.outputs.api_url }}"
          Write-Host "WebSocket   ${{ steps.ngrok.outputs.ws_url }}"

      # --------------------------------------------------------
      # 4) 배포 성공 시 Discord 알림
      - name: Discord Notification (Success)
        if: ${{ success() }}
        shell: powershell
        run: |
          $webhook = $env:DISCORD_WEBHOOK_URL
          $jsonBody = @{
            "content" = ""
            "embeds" = @(
              @{
                "title" = "배포 성공!"
                "color" = 65280 # Green
                "fields" = @(
                  @{
                    "name" = "REST API"
                    "value" = "${{ steps.ngrok.outputs.api_url }}"
                    "inline" = $false
                  },
                  @{
                    "name" = "WebSocket"
                    "value" = "${{ steps.ngrok.outputs.ws_url }}"
                    "inline" = $false
                  }
                )
              }
            )
          } | ConvertTo-Json -Depth 5 -Compress
          $encodedBody = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          Invoke-RestMethod -Uri $webhook -Method Post -ContentType 'application/json; charset=utf-8' -Body $encodedBody

      # --------------------------------------------------------
      # 5) 배포 실패 시 Discord 알림 (롤백 직후 실행)
      - name: Discord Notification (Failure)
        if: ${{ failure() }}
        shell: powershell
        run: |
          $webhook = $env:DISCORD_WEBHOOK_URL
          $jsonBody = @{
            "content" = ""
            "embeds" = @(
              @{
                "title" = "배포 실패!"
                "description" = "배포에 실패하여 이전 버전으로 롤백했습니다."
                "color" = 16711680 # Red
              }
            )
          } | ConvertTo-Json -Depth 5 -Compress
          $encodedBody = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
          Invoke-RestMethod -Uri $webhook -Method Post -ContentType 'application/json; charset=utf-8' -Body $encodedBody